# Rewrite of TenhouDecoder from ApplySci
#
# Source:
#  * https://github.com/ApplySci/tenhou-log/blob/master/TenhouDecoder.py
import urllib.parse as urllib_parse
from typing import TextIO
import xml.etree.ElementTree as XMLElementTree


class JsonSerializable:
    PRIMITIVES = (bool, str, int, float, type(None))

    def serialize(self, *args, **kwargs):
        serialization = {}
        for (k, v) in self.__dict__.items():
            if isinstance(v, JsonSerializable):
                serialization[k] = v.serialize(*args, **kwargs)
            else:
                serialization[k] = JsonSerializable._serialize(v, *args, **kwargs)

        return serialization

    @staticmethod
    def _serialize(obj, *args, **kwargs):
        if isinstance(obj, JsonSerializable.PRIMITIVES):
            return obj
        elif isinstance(obj, (list, tuple)):
            return JsonSerializable._serialize_iter(obj, *args, **kwargs)
        else:
            raise Exception(f"Serialization not supported for: {type(obj)}")

    @staticmethod
    def _serialize_primitive(obj: PRIMITIVES, *_, **__):
        return obj

    @staticmethod
    def _serialize_iter(obj: list, *args, **kwargs):
        return [i.serialize(*args, **kwargs) if isinstance(i, JsonSerializable)
                else JsonSerializable._serialize(i, *args, **kwargs) for i in obj]


class Tile(JsonSerializable):
    _TILES = """
        1m 2m 3m 4m 5m 6m 7m 8m 9m
        1p 2p 3p 4p 5p 6p 7p 8p 9p
        1s 2s 3s 4s 5s 6s 7s 8s 9s
        ew sw ww nw
        wd gd rd
    """.split()

    def __init__(self, i):
        if isinstance(i, str):
            i = int(i)

        self.i = i
        self.tile = i >> 2
        self.tile_num = i & 0x3

    def serialize(self, *args, **kwargs):
        if kwargs.get("readable"):
            return Tile._TILES[self.tile] + str(self.tile_num)
        else:
            return self.i


class Player(JsonSerializable):
    def __init__(self, name: str, rank: str, sex: str, rate: int, connected: bool):
        self.name = name
        self.rank = rank
        self.sex = sex
        self.rate = rate
        self.connected = connected


class RoundNo(JsonSerializable):
    ROUNDS = ["E1", "E2", "E3", "E4", "S1", "S2", "S3", "S4", "W1", "W2", "W3", "W4"]

    def __init__(self, round_no: int, honba: int):
        self.round_no = round_no
        self.honba = honba

    def serialize(self, *args, **kwargs):
        if kwargs.get("readable"):
            if self.honba == 0:
                return f"{RoundNo.ROUNDS[self.round_no]}"
            else:
                return f"{RoundNo.ROUNDS[self.round_no]}-{self.honba}"
        else:
            return self.round_no


class Round(JsonSerializable):
    def __init__(self, oya: int, starting_hands: list, round_no: int, honba: int, rii_sticks: int):
        self.oya = oya  # Round dealer
        self.starting_hands = starting_hands  # List of hands

        self.round_no = RoundNo(round_no, honba)
        self.honba_count = honba
        self.rii_sticks = rii_sticks

        # Who won the round
        self.agari = []

        self.events = []

        # Did round go to exhaustive draw
        self.ryuukyoku = False  # Can also be a string, if it's special (idk)
        self.ryuukyoku_playes = []

        # Riichi
        self.riichi_players = []  # Which player(s) rii
        self.riichi_turns = []  # What turns rii happened on

        self.turns = [0, 0, 0, 0]  # Final turn for each player
        self.score_changes = []  # Score changes, divided by 100


class ChiiMeld(JsonSerializable):
    def __init__(self, data: int):
        self.from_player = data & 0x3
        self.call_type = "chi"
        t0, t1, t2 = (data >> 3) & 0x3, (data >> 5) & 0x3, (data >> 7) & 0x3
        base_and_called = data >> 10
        self.chii_type = data % 3  # Ex 456 -> 0: 4 chii, 1: 5 chii, 2: 6 chii
        base = base_and_called // 3
        base = (base // 7) * 9 + base % 7
        self.tiles = (Tile(t0 + 4 * (base + 0)), Tile(t1 + 4 * (base + 1)), Tile(t2 + 4 * (base + 2)))


class PonMeld(JsonSerializable):
    def __init__(self, data: int):
        self.from_player = data & 0x3

        t4 = (data >> 5) & 0x3
        t0, t1, t2 = ((1, 2, 3), (0, 2, 3), (0, 1, 3), (0, 1, 2))[t4]
        base_and_called = data >> 9
        self.calling_player = base_and_called % 3  # Who called the pon/kan
        base = base_and_called // 3

        if data & 0x8:
            self.call_type = "pon"
            self.tiles = (Tile(t0 + 4 * base), Tile(t1 + 4 * base), Tile(t2 + 4 * base))
        else:
            self.call_type = "shouminkan"
            self.tiles = (Tile(t0 + 4 * base), Tile(t1 + 4 * base), Tile(t2 + 4 * base), Tile(t4 + 4 * base))


class KanMeld(JsonSerializable):
    def __init__(self, data: int):
        self.from_player = data & 0x3

        base_and_called = data >> 8
        if self.from_player:
            self.calling_player = base_and_called % 4
            self.call_type = "daiminkan"
        else:
            self.calling_player = self.from_player
            self.call_type = "ankan"

        base = base_and_called // 4
        self.tiles = (Tile(4 * base), Tile(1 + 4 * base), Tile(2 + 4 * base), Tile(3 + 4 * base))


# Is this just Pei?
class NukiMeld(JsonSerializable):
    def __init__(self, data: int):
        self.from_player = data & 0x3
        self.call_type = "nuki"
        self.tiles = (Tile(data >> 0),)


class Event(JsonSerializable):
    def __init__(self, event_name):
        self.event_name = event_name


class CallTileEvent(Event):
    def __init__(self, player: int, call_data: int):
        super().__init__("call")
        self.player = player
        if call_data & 0x4:
            self.meld = ChiiMeld(call_data)
        elif call_data & 0x18:
            self.meld = PonMeld(call_data)
        elif call_data & 0x20:
            self.meld = NukiMeld(call_data)
        else:
            self.meld = KanMeld(call_data)


class DoraIndicatorEvent(Event):
    def __init__(self, tile: Tile):
        super().__init__("dora")
        self.tile = tile


class DrawTileEvent(Event):
    def __init__(self, player: int, tile: Tile):
        super().__init__("draw_tile")
        self.player = player
        self.tile = tile


class DiscardTileEvent(Event):
    def __init__(self, player: int, tile: Tile):
        super().__init__("discard_tile")
        self.player = player
        self.tile = tile


class RiichiEvent(Event):
    def __init__(self, player):
        super().__init__("riichi")
        self.player = player


class Agari(JsonSerializable):
    # There is more data but this was not needed for my usecase, so this is just here for posterity sake
    def __init__(self, win_type: str, winning_player: int, points: int, from_player: int):
        self.win_type = win_type
        self.winning_player = winning_player
        self.points = points
        self.from_player = from_player


class GameData(JsonSerializable):
    PLAYERS = ["n0", "n1", "n2", "n3"]
    HANDS = ["hai0", "hai1", "hai2", "hai3"]

    def __init__(self, log: str | TextIO):
        self.game_type = ""
        self.lobby = ""
        self.players: list[Player] = []
        self.rounds: list[Round] = []
        self.results: list[tuple[int, float]] = []  # Tuple of (final_score / 100, uma)

        self.decode(log)

    def reset(self):
        self.game_type = ""
        self.lobby = ""
        self.players = []
        self.rounds = []
        self.results = []

    def tag_GO(self, _, data):
        # The <GO lobby=""/> attribute was introduced at some point between
        # 2010 and 2012:
        self.game_type = data["type"]
        self.lobby = data.get("lobby")

    def tag_UN(self, _, data):
        if "dan" in data:
            names = [urllib_parse.unquote(data[name]) for name in GameData.PLAYERS if data[name]]
            ranks = GameData.decode_list(data["dan"])
            sexes = GameData.decode_list(data["sx"], dtype=str)
            rates = GameData.decode_list(data["rate"], dtype=float)
            for (name, rank, sex, rate) in zip(names, ranks, sexes, rates):
                self.players.append(Player(name, rank, sex, rate, False))
        else:
            for (player, name) in zip(self.players, GameData.PLAYERS):
                if name in data:
                    player.connected = True

    def tag_BYE(self, _, data):
        self.players[int(data["who"])].connected = False

    def tag_INIT(self, _, data):
        round_no, honba, rii_sticks, d0, d1, dora = GameData.decode_list(data["seed"])

        new_round = Round(
            int(data["oya"]),
            [GameData.decode_list(data[hand], Tile) for hand in GameData.HANDS if hand in data and data[hand]],
            round_no,
            honba,
            rii_sticks
        )

        self.rounds.append(new_round)
        new_round.events.append(DoraIndicatorEvent(Tile(dora)))

    def tag_N(self, _, data):
        current_round = self.rounds[-1]

        calling_player = int(data["who"])
        current_round.events.append(CallTileEvent(calling_player, int(data["m"])))
        current_round.turns[calling_player] += 1

    def tag_TAIKYOKU(self, _, data):
        pass

    def tag_DORA(self, _, data):
        current_round = self.rounds[-1]

        current_round.events.append(DoraIndicatorEvent(Tile(int(data["hai"]))))

    def tag_RYUUKYOKU(self, _, data):
        current_round = self.rounds[-1]
        current_round.ryuukyoku = True

        deltas = data['sc'].split(',')
        current_round.deltas = [int(deltas[x]) for x in range(1, 8, 2)]

        if 'owari' in data:
            temp = [[int, float][i % 2](j) for i, j in enumerate(data['owari'].split(","))]
            self.results = list(zip(temp[::2], temp[1::2]))

        # For special ryuukyoku types, set to string ID rather than boolean
        if 'type' in data:
            current_round.ryuukyoku = data['type']
        if current_round.ryuukyoku is True or current_round.ryuukyoku == "nm":
            tenpai = current_round.ryuukyoku_tenpai = []
            for index, attr_name in enumerate(GameData.HANDS):
                if attr_name in data:
                    tenpai.append(index)

    def tag_AGARI(self, _, data):
        current_round = self.rounds[-1]

        # agari = Agari()
        # self.round.agari.append(agari)
        agari_type = "RON" if data["fromWho"] != data["who"] else "TSUMO"
        agari_player = int(data["who"])
        agari_fu, agari_points, limit = GameData.decode_list(data["ten"])
        agari_from = int(data["fromWho"]) if agari_type == "RON" else None

        current_round.agari = Agari(agari_type, agari_player, agari_points, agari_from)

        deltas = data['sc'].split(',')
        current_round.deltas = [int(deltas[x]) for x in range(1, 8, 2)]

        if 'owari' in data:
            temp = [[int, float][i % 2](j) for i, j in enumerate(data['owari'].split(","))]
            self.results = list(zip(temp[::2], temp[1::2]))

    def tag_REACH(self, _, data):
        # Note: This event is fired AFTER you discard
        if 'ten' in data:
            current_round = self.rounds[-1]
            player = int(data['who'])
            current_round.riichi_players.append(player)
            current_round.riichi_turns.append(current_round.turns[player])

            current_round.events.append(RiichiEvent(player))

    def default(self, tag, _):
        if tag[0] in "DEFG":
            current_round = self.rounds[-1]
            current_round.events.append(DiscardTileEvent(ord(tag[0]) - ord("D"), Tile(tag[1:])))
        elif tag[0] in "TUVW":
            current_round = self.rounds[-1]

            player = ord(tag[0]) - ord("T")
            current_round.events.append(DrawTileEvent(player, Tile(tag[1:])))
            current_round.turns[player] += 1

    @staticmethod
    def decode_list(thislist, dtype: type = int):
        return tuple(dtype(i) for i in thislist.split(","))

    def decode(self, log: str | TextIO):
        try:
            events = XMLElementTree.parse(log).getroot()
        except OSError:
            events = XMLElementTree.fromstring(log)

        tags = {key[4:]: getattr(GameData, key) for key in GameData.__dict__ if key.startswith("tag_")}

        self.reset()
        for event in events:
            tags.get(event.tag, GameData.default)(self, event.tag, event.attrib)


def test(old_log, new_log):
    ROUND_NAMES_OLD = "東1,東2,東3,東4,南1,南2,南3,南4,西1,西2,西3,西4,北1,北2,北3,北4".split(",")
    ROUND_NAMES_NEW = "E1,E2,E3,E4,S1,S2,S3,S4,W1,W2,W3,W4,N1,N2,N3,N4".split(",")
    EVENT_NAMES = [("Dora", "dora"), ("Draw", "draw_tile"), ("Discard", "discard_tile"), ("Call", "call")]

    with open(old_log) as f:
        old = json.load(f)
    with open(new_log) as f:
        new = json.load(f)

    assert len(old["rounds"]) == len(new["rounds"])

    for i in range(len(old["rounds"])):
        old_round = old["rounds"][i]
        new_round = new["rounds"][i]

        assert old_round["hands"] == new_round["starting_hands"]
        assert old_round["dealer"] == new_round["oya"]
        assert ROUND_NAMES_OLD.index(old_round["round"][0]) == ROUND_NAMES_NEW.index(new_round["round_no"][:2])
        assert old_round["round"][1] == new_round["honba_count"]
        assert old_round["round"][2] == new_round["rii_sticks"]

        j = k = 0

        while j < len(old_round["events"]) and k < len(new_round["events"]):
            old_ev = old_round["events"][j]
            new_ev = new_round["events"][k]

            if new_ev["event_name"] == "riichi":
                k += 1
            else:
                # Need to check the event contents
                assert (old_ev["type"], new_ev["event_name"]) in EVENT_NAMES
                j += 1
                k += 1

        assert j == len(old_round["events"]) and k == len(new_round["events"])


if __name__ == '__main__':
    import json

    test("log.json", "log1.json")

    # import bz2
    #
    # hex_str = "425A68393141592653598C2B83CC00110D1F80520FFFE73FFFFFF03FFFFFF06019DF3EF8DE6F8950122A85056EE74C6CB405AF3DBBD3C1EF77ADEBBEF0E7CF3B8F6EB8EDD71D73B79DCE7A359EB6AC000B6DB50DAC06FB007400089026026234C460008C1346262626453548C22260802621810D32698994DA8DA6949FB11A8A7EA34D06A9E0C48A52806D46268D1A68D0F50000D00006A7A6805249913486D43D4DA691FA9A6D14D00D0D006804A7A9464D0828CCA36A1B48D001A68006800341228984353226A6C80461180A9F8429F888629A0F51A40718BADA800836B49073B15CC11D6238E0241F1FBCC088C47304020A02828281041ABDDC0F66FEC64B7A319C271BA51951E2BAF4DC97CD2A5EC5653012B7AB24AB349A374E184B999953169EA7D4A22EF29AE139A9E39230C20CE43B21444C415C20886413B868C61DF5EC222E090DD11F6BE43190C820DC64A38F2511DB6BB32887B6E54DBB534CA7762D4E89E063C8880B28DD47D39DA571856D694A6CC404928331863812E7BF0CDD39945073144A1D92A64298EC199871AB2B96CBFF5E23E9250FC0BF033E36BD32E77CEF6F7F423F15FFBFB8996E3C7EF9682470A5A274C72B6B016324263100D0018082028C421A442963DB684132CAD83023969B8116FA62E605022CBA0D224D1E288C18B68526EF65C46C0721D54E32A9CDE99889BAB974E32B5C6C3DC12DE58A9B860AB9F34AAD085C6DA0A069D97E4BAA9C069BC26E274211517B4D649405E3991272320302EB04B6724D44AA3513351CC45594F44622CF46A6F18629B8BB4C20BC27749B0F21DB808A355724C842C64658232881699BD9ACB191B0DBCC6EB6CE6C8B5966CBD55E0104326E382C9E452A30F5409C8BB70E3096E2B34830A7A9081F35DDE9575226D235B7E51AC140C60C5A74B8CC6AB6EAD6196D4C9C468AC39B1B34CA0B277348A82CB360B37AA5AB3130B16E501312202811513B3332921572F748D20CE54CEA2B29543D846A4564406B20C564D5B57B3A69C590F6F6A7127B72B0B79B2C59751AC8B931931ACB4A6DCECD9A7E56C5EA2F42833A197A1511AE624D40C784C1D7904636D9999F32355194A22A02DA929D2899192DD98627B770D98A0E236555D3871DB95FA79CE63FDF5A7B3A2B57D3FCBE7EEFC7F678759DDE73DCBC09EEDA59E683AF865C62B7C7B2CD20D58C974741998E545D907CD8B2EB22D42E034B36CE3BDD775AF97381CF2D0911C1CD70D64919BB531677545CE51144D87210C17052AC28375F31E08D1BDDDA172B9CE732BAF3968EBE74954454529CB471AA78F3C6DE40D878D556143334465368541DECDA8198D0E58B7C9810C73502DDC571EC4D9090ABB328606BCC3025DCBC436E5B6BD7506F03BCA30FAFAAAF7A5B85DDBE45DE1A3DE11C53A2A79B1BB28C3E431B19665B94318755C27985CEF34833C3714965D1C967776038D99BF2599BBA0D88CEE0E70778E208AF00AB7C31B9DED1433996AA1396EB3A1D5D93473341853B0EB356C4433BDB0B48CDCD2752A78CC6698A56763444B2AA4FAE677325F1E5AD0C266682499388479B771C98736F2EA771EAB175CC9941C42E4A1886F23164CB36A8E6C5F0F2F2F6420F762E06D60C55584C736686C3AE07BE2E994D08AEBE9EC9C5C75DB9B9B8C793CDA9253DD9E6D6D29E51A271C1D8E28C64F0A4EEF774E71CF06728982B2EAF931769329735546C9E6690DD4E6078672B141211DA991A6C327C29F28B3CBBA6101F5E734453A357B724837AEA6E8D4157C7B962BC51317892BC8D345A86554419072548C783E6C36FE42A86520E573EA247E3DBD8770BEF31A76259FD8FCF07F66FE98B0E538212972DD70480BA1744E59F3461C334A26DF5E195F8BB502295B11644719810798FC841BB767CFA76CE772D7B41DD8C473A5AC2B1DDD75D181808F3665C98E1E0788D82449E8840DCD54612FAFD19C13D0C4DBD595DCA1115A126F77454FABAAF93DBD07BAC109FB5B9BD488A8EC4755CF8584F73F1EF465AD2129DA597DCE3B97ED96964F71DA93B73F8DBA1BD8B36F9F6A1A3FA20F2ED057460A608645DC450BE9C308B1B41B9E109B1B1170D0B36DA160C175300C49774502A43EC91FBD3DDE9776F2EAFCEBFD5FC5E10D0F4FA5B0FBEC7DFC7D9F6ECECFADBFBBBDFF4FEE349E8E5EE4778737444224D812F8CEEE7529B20CA460792821CFD081420408881F2AE7D6F9BBEBCD0715156B3148F40CD87AB1AE497371DD1A9496900916CC5A68CEC48CDB53AC2B36DC0971A92FA3E3D75872BE3DBB15324B762AD3CF7329CEC6AA887D45B906A6981EE4AF8361E67BB8B2C4FC627B96CFF2FA680A81E4413349A607830F0668694D2B8BB4995C2ACBE520B857DD3BAF241EF679B84678346DF8F0601888410208162FCB599E0241F08CF300D26CF8849D8F3706836067F79EC42ECF6005183060CF2182073C24F7A925E7AD4824478FC782C0917E022FC22C5E864107CC02C3176C3F080D104827C183333CC18094925C710047BD1B0FC8E40DD121FADF07B124732044324F422147839E91F0E7837C77605F896E30A41D8416A5E2D080411041C0E336CC3C1E31BA2C5EC0D1B7A0EF9D0DF62A22036F13180D817B2D20A32D32D4B5AD1A255A14A4894B1273A9332679153CBAFDD42AB8287101BB82C3F37DEDDDDE5810787AB0C5ED15648CDC1907E6E3419329034670326A0B76A6CF5969B8834219264C46BE22B52F67AF372AB293A8B4B698E162918E06DE9CAB58561D99DC6470139A46FB165606E5DB6935388856A8318C5CECAC0417C52305FC9B3D3EE3ACD0E28992CA750687A3201BFB713E698E8369620C7476F8F4FEDC77BCBE9DDCC6CE701F6C62AA78404E528A86D719C2E1526A316E3E03E04C25F52043D306AE294BD87372394F42E31F21B0B75AFB7993CAE38A641D410B330690ED3E7323CAA79C68E47BF86CA9468DF6EBC9E71A6E9C5BE2EB6C7A8298D318EC0A21B5B77CA7E3B70B1EDDBB6C45168F5F96CF038F47A3E0CE3D5E916BD27D27CE6BE4078C6332191096430428974119C84B3322AE4E54982F80D12D64B8469260E79C91ECDF8174319C96B4C45F06333028A5242F1B21CE8D02B030A20C65AE697CCC18A9489C18D22D2B042653B3C15A2A62E884342E114D8DE2B0C62AD5D1A098B2F3E170FA1C92E58CED3B931635A7D72F3C41BF8B9B8F6FAFA3923EDE2588ACE3379799B1857A5D05CBAB55D2F57D838EFE5DA08DB8F5D90F1103E4371288E58239F8FA5CBE2B1B7967E795C63A6191A34E6F4E508B7A278671BAB26E549DC42B2EE21358C6CD42634CE9BC50D4AA245DE01F23E4470AC12EBB9A3922C446CEDA25E8B8C3F19E7198E6FC4617739B3D4E6E54A42AB6F8E1D9BD15D7CCD546A8208AE778F0604866058B3316D7635D6D5EE4481EBCF290498C9421DFDDDD7061A8813289C1B42B229B76985CB8699B79B12E510632D72598B096E99C6C4B1966161859ABCAEE94B936C1D9DAB07585995D65431AA79D720803D7E290FCF4FD68DD5E7B3D9E4F6383D73839A7C6D501D600C11E1E23A8041030A45A1FF3CFF68D65F19E58B1FD28CA489C60867BD0707FFAC28B4E9590FDFE3E5F2F8377B2FAFE7FA9269F1F161F33F94FAB726CFCCCC82818ACE4B72571EEAB2DA9034FDA06D308C3B8AF751D872DAA19D677C0362D8DE754AE97D0ECB647AD7760A676275E1A4F24F6EA71EB5EDDC809284EE5A83218EBDCF15074545E378DD5B0FC978E8F4B6BC3CE493646243AD65637A48DC3AE52A485AEB39646FE67FEAF830BCBEFBEF584FDB1BF1B8DEC8B16CAD6A2264AED03D1498AB3AFD3514734531C6FAE0EA21C1A4840200E08533426024D3550630C7665D7859354EB27A39B25A6A32B20EE3EC1968E842E0675FBA7F926D51DF98F5CEA55CABB0B3D232D8828F8A6818E718A721C808511ED9CE77BBBABC93004C0B076148310097B879750DDF26A1313C4C51BCB0CDAA75F55F1F440817D9CE55333997DADD40C1871503A0C30B4E79AAFDDB17412C76D834F5ADCEB04FB2E36215ECC6B4C634C2170E348D6237934035D3B0CCCFA8906E36D5C7C32BBC5C9378307FE606E98DFBB71C1BBB629509ACE9BB8932CDB83286A27BDAE45999B20CA52D6BE429671D7CDB26895664F0967FA86861A0BCCC8DCDF31C8011290DCC0AF3E92A12FB912D8DB31147D5BBBFDEFCBD8E5415FECE07FE68A4D37DE99FE7D3F67C07AFDBEDE78FC3F4305FABDB34077931B9D0EA2709F261920EFD7112E6CD2ED664EA2509EF6D48DE9B30C4C89F6D5DE60B5435E7BB83A89C45CA76724192FB98ECADA6A34DBF7A10A08912F5865767904741DE72D8B8FE8A506CEFF03A976617CEAD2C6E346F6A92D98E263EFC7566EA8FC5F7DFB3A7F5BD89AC301B62617EBC30C35EBA2F714DC52246914CD4CA638E37E2A766E94B567631A6EE5805F52C5B0C2FD3CBD58A3DAB8DD212C7AB3199F1DF5F83D245AC49FEFE8A89A562F53DFBC55A209C292798DDA905CC020601C45FB1DCFC3DF028FAF4407EC64F05AECCBB68997461BB32AADDEA3146EE74E55EF5FE44BBCA5144CDDE7A9F95CBEBC749766BCB5ECD21A23772B270E7227DF77A1E7E578EA146EBBCFBC92CF1128B9CEAEB7CB553531EA599950E4B4DB27B877D1747CB3F7CB6E7806DC71EF58DC6932B1CBCD8763B356CAD8E2734D13C89CD4D6E1C58F05B080D6DD0B0AADCDBF5A5E30BA852D1388E1CADC57906B7370C37302F3F8CA1544AB532BCBB2D56BF5E02380E2F2C1C99AC9EA1CE27B2A1BA6D62E6E6F4301461A87B215F87623D2487124754EF9E36ECFCFD65CFC1D6F876C227610E8EAE5F19CEB3A52F20CE3993A2C2F74A47B9BA97565F10742F6416EEFADF8772F2276B6960139F83BA6DBB43E2EACCAB79E847757C8CE72BA76CC6E6BB391EECEE86EE5BA17E50776724E4EC2DB9156A2187987B88FB8F3C3BBDFDCE24101FC3DA0F957A322A3AA30BEB7F757A74D554A52D5F76BDB5DAD14D0F64458DCAFD549172B15AD061026073AAA6A75904C621EA4C30B0A20058AA2F0AF1799F87AE39635A5E3235BCB2E8DD56B71FB38C36F24DA53F88D7FADF8B33CF436B51C9657818E044507181C6302A028CB0A6D225D62B1F94707BEEA069342EA7793BCB1D8DB59C4F1F3204C845A2AF2DDCCC5F29EAE54FC8DCDB937C4521EE41874D2A1C9DC5B133298D3CA0BBFB4479BCC09E78FD5E1F3BC10076F1F3F6EF1D1316184CA76FC787577DE41856B5AEF666F6FEEDE30654AEA2A7E793C681356A70EB909E7BC4540B4EDB0CBC286E46031D4A952BC12150C8AFB37D21E7C3EBB0559BC7B557DB2EFD2F97DAAE4FC4712272E976E239698F9F9E7A566B8CFD391FE831FD8081251FAF4F474EE9A845A1C6C3DED7ABBA8C9911A4BE629C49AC09E1570C2E2E817439E1EBF0A1D10BC2F8C4A680C4182D02D07C2B8E8D17E2B143794488452806565A0605A32092AB2ADBC5CE110172488661109113AC8E48AA934E9A64B26E798814446552371C55EA10800EE6092429F576699FF5D387EB4F9EFF982F5E73DBFE88018C7C4897327FA0925F0200D38581FE420FE3DCEFD2FBB798355DBF7E7E6E5519CFC7154DDDA4119BF260BEB8B77FCDEFE047D3CAFDBDDBA753F3C5BDFE451FA527D894297B99C72E627FF3584725FECE223CDAD9BFFE981CEF757C0005F2122FE537CFDD3601EB4ED76796866BE95D6959814570BBC2780840200C4605460005AEC0810B794388041057D6FFEA612F5CD07564FBF586BEBBB93FC7C25D5BFF0E6F2FD6FC75F26C0497B26923D584180B8D81EA0AA35B2212DD33A666B83AA4F5F87A28E97F2D5B5BB91E89C9CC38A96BBBD5BBC1F0F8A3E9B831F8EEBD7D3F223C5E5B6E4925F7691E2C12E5696C61E8D12FBFBBB3D3CB8BBFF14DFE17F20F4C42613C14CD835E7891AB75F34B376AD15DFB0042014231006918084081808052BE200691D2F9F761AE669C5EEF50D112293C375F4F0F1A10FBBF1C08252FA4C96445C771DC8B4A39789E0025A9DDDCB4AA358589BB0A35A4CFB3DAE1DB9AE4D96D36BF7340056F337346EB29510E564362B60803D37B3F6551416BF0394AD9C21DED4F85A020E63E3EB8008064E1E0692CED017F75BDEF1CC9E35F6F49F94D3E8A3FE67F7EA25F4DDD9BACC9B2E3DF82189F9CBF6C658875C5BE0A286745AE9F5E09C1CE725A3BD50767ED0B59A20CD870AB9896937E6F7D442F522741DED2B2427E33AB995CBDB895CF11190FA86797769BADFCB9DA8F4F1A73E6FF2E46B9CAABD1D218707DB646796B124AE3EA895A7D1A41F99DD7CD98DE948B6DC0D403FB53C70FF72EACC39CAEF0ABA2B26DE1BE75E5586509B74E3D046F2EC1D9AC8A55A31DC5AEDC10B33444EC0002C20F65067911BF4C02C629B3A00834316878B97B5E3DE55446666489A6CBFEA7268D8D3B2697B6BF7516968BB1743BF97AF965494359557768CFBC27C9A0A5F6247515EBFDB79E87DF62B4F61F7927C81E9AF17EB2D543B1FD22AB50A219AEFC9D2E241C7A6986EE72BD28CAE0BBC856747C3EDCC722EC671FDB429F77E0572BF54B1EB5E85D08B710DD255111A6DCAC14C8C6363E89F0BF0A6704DCCEB90A55479AFAE43C89905E337231366E93CA35B6751CEEA28D3A75B3B743371E08C367BD400472538802432ECA5EE3C58ADD4F9346AB52434C73AEF77968E7884A8E7E5DB0CDF771BD1EF291743CCDB304BA323BB8A74F77371765979356306B1D1AB38DAAA4973DC46F573E34A78EAD1E5C30DBE423D7570A0472CE01FE182FCB4A1E70011E2CF8FA69E4AF06FCFDBA9252AA6ABEE92F6B4DD3D0DB7E59C6E774CC1B100006C3000038308002C1842386002D0F242000C8A90801AAF39BDE9A376BC8E3D2AD8BE0653274F958DC26DFA2378D4E8E8E7E4D7E9D6BE94E0E3FCF5F761D1D3C6805C8D01D7E9005E4D25EF697F2D002575DE0ACB52A7BB3F9E3E670D14D6E4B70E48DBF5254770DBB46BCBC7D8E7F0AB4A6B950AD1E3E0E7FC3041D4D1A1A1197BE024BD7BE0979B41D9E997CB6F47F596CE4CFC3B284E2851E9D739154E979E27650041E9FDF2C2A668CB3D9DE942B455AF95A99BBBB245A57DB20EACD11E526AA6BB047442C6A394D611F7928CEB130AA72E6FF276730821DBCA4DFE8C5B158BC722DB6694DC2CE668AFAD8E6D9A5914D5E51C2FD9CF3C38C76CC54771BEB840110159D721E5FAE862A5E5832570E39EC9D67BB60C0B408389FCEDE6440DCF1E152415DCF913BC7AE5D0BABAE16C99C1D681200006030180B40BA36CD74CCFDE9800967585B2DD370EDB353197C42E77DFE8D5FCD1079F6F6ECF0B0923EAD8DA6D8DB0EEF820F2D5DE7AFF1D7AFE5CAD7267F4E5727EB5E11C4BA4CA5A9F696B67E3D93397BB12B106DED8D7CA26FFA020FB8CFF1AF5BCF62E43DEBA3B5A12DF44D86F3E3E80208EABF0B9D045ED1FC0656F1F6547DFDD91000F571E86EAE23D77CD718E2A571061A230FDE7300176D7D657CD88EC56C75EDF78CCFDAE773B6FBEBAA08266BC3EE00164A979F04D3A3EAB69D4AD7A0556A2BCE2C9B4B77CE78C5F494AB8E69D42E9F287540420ECC084054D06B9F0544002FA3000AD7B066A9663D2CB8F9D7936BFC8DE67D2D91328CF85461CC95DBDF92A0A1C761892C2C1001F4736E2BE3AF79EB56D1309EF15CA00A7C2CE432AA9CE3BF1518D3E48757C018AD373E7144ED01FB79295E8B829D2591DF7E2C97A784BAE7DA48BDA791F595899B9079C26FF00020153336D44E3C737F4400EEE1003803000861921A609A66E7367F639BDB6FCF650DCFC6BF77B76A447BA022E68478747CFC79AB581E392581515585E1EDF9356EE4F0F2EFA7477B4E88F9F27CB4F2FD3E33C1E93B851C4C264F9A916D5879B29C1FCE1F4DAE64E92D9FA023EAAAF9B2A53E6B4BCCF1AF06A0DBE6DB44A78C2A2838F9A1C41EB225C1037BA9D16B9102BBAD37B3371795FBF1D4777B6D5DD7A045D3C8B61A3331F64BB1E84F4BB74F1708315210E2F7B36C97475BE5DC401C4CF33F071132CAA3820940923A68E4B902EDF7F76D7735770C6D82A495A998B4BA53B79D7ED987AF5B363B75C8B996683FB5D04400422F776CC777DE43D3CD2CE2EA2003FDD24839D14100505DBEE5ABF2AB61D29DD1DBFE539C51E0E91C9E1BFC37DEA3FE2CBEFD7467E88005C2377C79EC92AF82ED307F81FFD0A9580C855AE347929A2A12F86005A9A3B7D9D0F87931E9DE0F3967EF402100BEFDAE95E6FDB8759D2A4606F126831294238246EDFA9D14684010F456C30004420F5D583F63998E2104D49956D53E6914F50014AB6D58D69DF6D84DF4ED847B8A69C84E26BBE984887EB495A3F069E4C26CE4ACE174B7222E30535DDD56DC4F26A6CF5F12A73A736D1FBFD1BDB0DAA5BEACB0E184BBE2F8DE13F233728C66CF61D78C1BE509287038B69B6B229DD0DFF1F89EFED6FF2CAC5B08D001685EEC0B58ADC711CE7D5B896F10B70273B16182008D9FAE71D320D7857913CA955A66E64AE318EEF37ACA9337A64DCDF294EBB3ED9EE701067BC71081BF6A99FA79EB3F3E6A10D47BC005663C08F52A24DF7EB9109D12D9728A17F8949018F86EF27B0C258C0711C3D10B476FAABBEBB779D87C4002A0005E67B59576F9FACBB73479C7D07EE225492220A94FB7787EF7A2A44003E1819AC0E5F5426E14C9057EFF54B92C4CEAE54268EDD5C70DE7F9E30A2BA4ADECF32563D09C93F1667D175F0355735F734CCC4C28A344ADF0CEF4C9115228781033F5EFED3AC5F9E7EB0452CEADD4C7D3D444EF55EF70EEC6C4E45329E2E1226F880420EFF8955E779C56E6357AECD785BEC89716339937226E45A863CD6841EB796CA9495046A9575B393D8EDCB7CEDE3D6D2B079D0DE6B385B3783FDFC44C7B63154B594FAAD47A9DEF2CF2C784DE47A16AD910831100417F6BBE6B5F86E1476CCFCECAE4E3894B1CD0D78EBA7A6FB3D91D9435F9D9C1E573E2339EEF61146BBE39CCB4AA0875256D6B56F91919D177F553D95F835FF85DC914E1424230AE0F30"
    # compressed = bytes.fromhex(hex_str)
    # decompressed = bz2.decompress(compressed).decode()
    #
    # game = GameData(decompressed)
    # # print(json.dumps(game.asdata(), indent=2))
    # with open("log1.json", "w") as f:
    #     json.dump(game.serialize(readable=True), f, indent=2)
